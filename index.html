<!DOCTYPE html>
<html lang="en">

<head>
    <title>ᴄʜᴇʟʟ</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta
      name="description"
      content="A shell which allows you to vibecode javascript directly from your browser."/>
    <meta name="robots" content="index, follow" />
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- CodeMirror Assets -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>


    <style>
        :root {
            /* Default Theme: tokyo-night */
            --background: rgba(26, 27, 38, 0.75);
            --header-bg: rgba(20, 21, 28, 0.7);
            --foreground: #c0caf5;
            --prompt: #7aa2f7;
            --cursor: #7aa2f7;
            --border: rgba(65, 72, 104, 0.5);
            --shadow: rgba(0, 0, 0, 0.3);
            --error: #f7768e;
            --success: #9ece6a;
            --info: #e0af68;
            --file: #7dcfff;
            --directory: #bb9af7;
            --ascii: var(--directory);
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            color: var(--foreground);
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background: linear-gradient(-45deg, #111, #222, #111, #333);
            background-size: 400% 400%;
            animation: gradientAnimation 20s ease infinite;
        }

        @keyframes floatAnimation {
            0% { transform: translateY(0px); box-shadow: 0 10px 30px var(--shadow); }
            50% { transform: translateY(-15px); box-shadow: 0 25px 40px var(--shadow); }
            100% { transform: translateY(0px); box-shadow: 0 10px 30px var(--shadow); }
        }

        #terminal {
            width: 90%;
            max-width: 900px;
            height: 80vh;
            background-color: var(--background);
            backdrop-filter: blur(12px) saturate(150%);
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: floatAnimation 8s ease-in-out infinite;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            position: relative;
        }
        
        #terminal.crt-effect::before,
        #terminal.crt-effect::after {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        #terminal.crt-effect::before {
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.25) 100%);
            z-index: 10;
        }
        #terminal.crt-effect::after {
            background: repeating-linear-gradient(to bottom, rgba(24, 24, 24, 0) 0, rgba(24, 24, 24, 0) 1px, rgba(24, 24, 24, 0.1) 2px, rgba(24, 24, 24, 0.1) 3px);
            z-index: 11;
        }
        
        #terminal-header {
            display: flex; align-items: center; padding: 8px 12px;
            background-color: var(--header-bg); border-bottom: 1px solid var(--border);
            flex-shrink: 0; user-select: none; z-index: 1;
        }
        
        .title-bar-buttons { display: flex; }
        .title-bar-buttons .button { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .title-bar-buttons .red { background-color: #ff5f56; }
        .title-bar-buttons .yellow { background-color: #ffbd2e; }
        .title-bar-buttons .green { background-color: #27c93f; }
        
        .title-bar-title { flex-grow: 1; text-align: center; color: var(--foreground); opacity: 0.7; font-size: 0.9em; }

        #terminal-content {
            flex-grow: 1; padding: 15px; padding-top: 5px;
            overflow-y: auto; display: flex; flex-direction: column;
            position: relative; z-index: 1;
        }
        
        #terminal-content::-webkit-scrollbar { width: 8px; }
        #terminal-content::-webkit-scrollbar-track { background: transparent; }
        #terminal-content::-webkit-scrollbar-thumb { background-color: var(--border); border-radius: 4px; }

        #output { flex-grow: 1; white-space: pre-wrap; word-break: break-all; user-select: text; }

        .directory-line { color: var(--directory); font-weight: bold; }
        .file-line { color: var(--file); }
        .ascii-art { color: var(--ascii); font-weight: bold; white-space: pre; }
        .prompt-line { color: var(--prompt); }
        .error-line { color: var(--error); }
        .info-line { color: var(--info); }
        .success-line { color: var(--success); }

        .ai-output-container { border-left: 3px solid var(--prompt); padding-left: 15px; margin: 10px 0; }
        .ai-output-container pre { background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; }

        #input-container { display: flex; align-items: center; margin-top: 10px; }
        #prompt-user { color: var(--prompt); }
        #prompt-path { color: var(--foreground); }
        #prompt-char { color: var(--prompt); }

        #command-input {
            flex-grow: 1; background: transparent; border: none;
            color: var(--foreground); font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 1em; outline: none; caret-color: var(--cursor);
        }
        
        #editor-container {
            display: none; /* Starts hidden */
            flex-direction: column;
            flex-grow: 1; /* Takes up all available space */
            padding: 10px;
            position: relative;
            z-index: 1;
        }
        
        #editor-info { font-size: 0.9em; color: var(--info); padding: 5px 0; text-align: center; flex-shrink: 0; }

        .CodeMirror {
            flex-grow: 1; border: 1px solid var(--border); border-radius: 4px;
            font-family: 'Fira Code', monospace; height: auto; font-size: 0.9em;
            background-color: transparent !important;
        }
        .CodeMirror-gutters { background-color: transparent !important; }
        .cm-s-dracula { background-color: transparent !important; }

    </style>
</head>

<body>
    <div id="terminal">
        <div id="terminal-header">
            <div class="title-bar-buttons">
                <div class="button red"></div>
                <div class="button yellow"></div>
                <div class="button green"></div>
            </div>
            <div class="title-bar-title">ᴄʜᴇʟʟ</div>
        </div>
        
        <div id="terminal-content">
            <div id="output"></div>
            <div id="input-container">
                <span id="prompt-user">root@chell:</span>
                <span id="prompt-path">~</span>
                <span id="prompt-char">$ &nbsp;</span>
                <input type="text" id="command-input" autofocus>
            </div>
        </div>

        <div id="editor-container">
            <textarea id="editor"></textarea>
            <div id="editor-info">Ctrl+S to save and exit | Ctrl+Q to exit without saving.</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ////////////////////////////////////////////////////////////////////////////
            // --- DOM Elements & State Management ---
            // ////////////////////////////////////////////////////////////////////////////

            // Cache references to frequently used DOM elements for performance and clarity.
            const terminalDiv = document.getElementById('terminal');
            const outputDiv = document.getElementById('output');
            const commandInput = document.getElementById('command-input');
            const terminalContentDiv = document.getElementById('terminal-content');
            const editorContainer = document.getElementById('editor-container');
            const promptPathSpan = document.getElementById('prompt-path');
            
            // These variables manage the current state of the terminal application.
            let isEditing = false;              // Is the user currently in the CodeMirror editor?
            let commandHistory = [];            // Array to store the history of entered commands.
            let historyIndex = -1;              // Current position in the command history for up/down arrow navigation.
            let codeMirrorInstance = null;      // Holds the CodeMirror editor instance when active.

            // Centralized constants for maintainability and to avoid "magic strings".
            const constants = {
                FS_STORAGE_KEY: 'webShellFS',
                FS_TYPE_FILE: 'file',
                FS_TYPE_DIRECTORY: 'directory',
                HOME_DIR_PATH: ['home', 'root'],
                GEMINI_API_KEY: "AIzaSyAlx7Frm4gikE-T36u-T3hj8izUSfu3pcM",
                GEMINI_API_URL: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=",
            };

            // ////////////////////////////////////////////////////////////////////////////
            // --- FILESYSTEM CORE ---
            // This section manages the entire virtual filesystem logic.
            // ////////////////////////////////////////////////////////////////////////////

            let filesystem;
            let currentPath = [];

            /**
             * Creates the default filesystem structure.
             * @returns {object} The initial filesystem object.
             */
            const createInitialFS = () => ({ type: constants.FS_TYPE_DIRECTORY, children: { home: { type: constants.FS_TYPE_DIRECTORY, children: { root: { type: constants.FS_TYPE_DIRECTORY, children: { 'welcome.txt': { type: constants.FS_TYPE_FILE, content: 'Welcome to the ᴄʜᴇʟʟ filesystem!' }, 'example.js': { type: constants.FS_TYPE_FILE, content: 'console.log("Hello from example.js!");' } } } } }, bin: { type: constants.FS_TYPE_DIRECTORY, children: {} }, etc: { type: constants.FS_TYPE_DIRECTORY, children: {} } } });
            
            const saveFS = () => localStorage.setItem(constants.FS_STORAGE_KEY, JSON.stringify(filesystem));
            
            const loadFS = () => { filesystem = JSON.parse(localStorage.getItem(constants.FS_STORAGE_KEY) || 'null') || createInitialFS(); currentPath = [...constants.HOME_DIR_PATH]; updatePrompt(); };
            
            const resolvePath = (pathStr) => { if (!pathStr) return { node: null, parent: null, name: '', finalPath: [] }; const expandedPath = pathStr.startsWith('~/') ? `/home/root/${pathStr.substring(2)}` : (pathStr === '~' ? '/home/root' : pathStr); const isAbsolute = expandedPath.startsWith('/'); let pathParts = expandedPath.split('/').filter(p => p); let resolutionPath = isAbsolute ? [] : [...currentPath]; for (const part of pathParts) { if (part === '.') continue; if (part === '..') { resolutionPath.pop(); } else { resolutionPath.push(part); } } let currentNode = filesystem; let parent = null; for (let i = 0; i < resolutionPath.length; i++) { const part = resolutionPath[i]; if (currentNode.type !== constants.FS_TYPE_DIRECTORY || !currentNode.children[part]) { if (i === resolutionPath.length - 1) { return { node: null, parent: currentNode, name: part, finalPath: resolutionPath }; } return { node: null, parent: null, name: '', finalPath: [] }; } parent = currentNode; currentNode = currentNode.children[part]; } return { node: currentNode, parent, name: resolutionPath[resolutionPath.length - 1] || '', finalPath: resolutionPath }; };
            
            const updatePrompt = () => { let pathStr = '~'; if (currentPath.length === 0) pathStr = '/'; else if (currentPath.join('/') !== constants.HOME_DIR_PATH.join('/')) pathStr = '/' + currentPath.join('/'); promptPathSpan.textContent = pathStr; };

            // ////////////////////////////////////////////////////////////////////////////
            // --- THEME & EFFECT ENGINE ---
            // ////////////////////////////////////////////////////////////////////////////

            const themes = {'tokyo-night':{'--background':'rgba(26, 27, 38, 0.7)','--header-bg':'rgba(20, 21, 28, 0.6)','--foreground':'#c0caf5','--prompt':'#7aa2f7','--cursor':'#7aa2f7','--border':'rgba(65, 72, 104, 0.5)','--shadow':'rgba(0, 0, 0, 0.3)','--error':'#f7768e','--success':'#9ece6a','--info':'#e0af68','--file':'#7dcfff','--directory':'#bb9af7','--ascii':'#bb9af7'},'dracula':{'--background':'rgba(40, 42, 54, 0.75)','--header-bg':'rgba(30, 32, 44, 0.7)','--foreground':'#f8f8f2','--prompt':'#bd93f9','--cursor':'#f8f8f2','--border':'rgba(68, 71, 90, 0.6)','--shadow':'rgba(0, 0, 0, 0.4)','--error':'#ff5555','--success':'#50fa7b','--info':'#f1fa8c','--file':'#8be9fd','--directory':'#ff79c6','--ascii':'#ff79c6'},'solarized-light':{'--background':'rgba(253, 246, 227, 0.7)','--header-bg':'rgba(240, 233, 214, 0.7)','--foreground':'#657b83','--prompt':'#268bd2','--cursor':'#657b83','--border':'rgba(238, 232, 213, 0.5)','--shadow':'rgba(0,0,0,0.1)','--error':'#dc322f','--success':'#859900','--info':'#b58900','--file':'#2aa198','--directory':'#6c71c4','--ascii':'#6c71c4'},'gruvbox':{'--background':'rgba(40, 40, 40, 0.8)','--header-bg':'rgba(28, 28, 28, 0.8)','--foreground':'#ebdbb2','--prompt':'#fabd2f','--cursor':'#ebdbb2','--border':'rgba(80, 73, 69, 0.6)','--shadow':'rgba(0,0,0,0.3)','--error':'#fb4934','--success':'#b8bb26','--info':'#fe8019','--file':'#83a598','--directory':'#d3869b','--ascii':'#d3869b'},'nord':{'--background':'rgba(46, 52, 64, 0.8)','--header-bg':'rgba(40, 46, 58, 0.8)','--foreground':'#D8DEE9','--prompt':'#88C0D0','--cursor':'#D8DEE9','--border':'rgba(59, 66, 82, 0.6)','--shadow':'rgba(0,0,0,0.2)','--error':'#BF616A','--success':'#A3BE8C','--info':'#EBCB8B','--file':'#81A1C1','--directory':'#B48EAD','--ascii':'#B48EAD'},'cyberpunk':{'--background':'rgba(13, 2, 33, 0.7)','--header-bg':'rgba(8, 0, 20, 0.7)','--foreground':'#f0f0f0','--prompt':'#ff00f1','--cursor':'#00f0ff','--border':'rgba(36, 0, 70, 0.5)','--shadow':'rgba(255,0,241,0.3)','--error':'#ff3333','--success':'#00ff9f','--info':'#fcee09','--file':'#00f0ff','--directory':'#711c91','--ascii':'#711c91'},'matrix':{'--background':'rgba(0, 20, 0, 0.75)','--header-bg':'rgba(0, 10, 0, 0.7)','--foreground':'#00ff41','--prompt':'#00ff41','--cursor':'#00ff41','--border':'rgba(0, 255, 65, 0.4)','--shadow':'rgba(0, 255, 65, 0.5)','--error':'#ff0000','--success':'#00ff41','--info':'#00ff41','--file':'#00ff41','--directory':'#00ff41','--ascii':'#00ff41'},'paper':{'--background':'rgba(245, 245, 245, 0.8)','--header-bg':'rgba(238, 238, 238, 0.8)','--foreground':'#212121','--prompt':'#005faf','--cursor':'#212121','--border':'rgba(224, 224, 224, 0.5)','--shadow':'rgba(0,0,0,0.15)','--error':'#d70000','--success':'#008700','--info':'#f57f17','--file':'#005faf','--directory':'#5f00d7','--ascii':'#5f00d7'}};
            const applyTheme = (themeName) => { const theme = themes[themeName]; if (!theme) return false; for (const [key, value] of Object.entries(theme)) {document.documentElement.style.setProperty(key, value);} localStorage.setItem('webShellTheme', themeName); return true;};
            const applyEffect = (effectName, state) => {if(effectName === 'crt'){if (state === 'on'){terminalDiv.classList.add('crt-effect'); localStorage.setItem('webShellEffect','crt-on');} else {terminalDiv.classList.remove('crt-effect'); localStorage.setItem('webShellEffect','crt-off');}}};

            // ////////////////////////////////////////////////////////////////////////////
            // --- UTILITY, API, AND EDITOR FUNCTIONS ---
            // ////////////////////////////////////////////////////////////////////////////

            const scrollToBottom = () => isEditing ? null : terminalContentDiv.scrollTop = terminalContentDiv.scrollHeight;
            
            const renderLine = (htmlContent, className = 'output-line', outputBuffer = null) => { const textContent = new DOMParser().parseFromString(htmlContent, 'text/html').body.textContent || ''; if(outputBuffer !== null) { outputBuffer.push(textContent); } else { const el=document.createElement('div'); el.className=className; el.innerHTML=htmlContent; outputDiv.appendChild(el); scrollToBottom(); } };
            
            const typeLine = (line, speed=15, className='output-line', outputBuffer = null) => new Promise(resolve => { if(outputBuffer !== null) { outputBuffer.push(line); resolve(); } else { const el=document.createElement('div'); el.className=className; outputDiv.appendChild(el); if(line===""){scrollToBottom(); resolve(); return;} let i=0; const t=()=>{if(i<line.length){el.textContent+=line.charAt(i); scrollToBottom(); i++; setTimeout(t, speed);}else{resolve();}}; t(); } });
            
            const callGemini = async (prompt, outputBuffer) => { const apiKey=constants.GEMINI_API_KEY; if (apiKey === "YOUR_API_KEY_HERE" || !apiKey) return await typeLine(`API key is missing. Please add your Gemini API key in the script.`, 15, 'error-line', outputBuffer), false; const tl=document.createElement('div'); tl.className='info-line'; tl.textContent='✨ Thinking...'; if(!outputBuffer) outputDiv.appendChild(tl); scrollToBottom(); const apiUrl = constants.GEMINI_API_URL + apiKey; const payload={contents:[{role:"user",parts:[{text:prompt}]}]}; try { const response = await fetch(apiUrl, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)}); if(!response.ok) throw new Error(`API error: ${response.statusText}`); const result=await response.json(); if(!outputBuffer) outputDiv.removeChild(tl); if (result.candidates && result.candidates.length > 0) { const text=result.candidates[0].content.parts[0].text; const html=`<div class="ai-output-container"><p>${text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/```(\w*)\n([\s\S]*?)```/g, (m,l,c)=>`</p><pre><code>${c.trim()}</code></pre><p>`).replace(/\n/g,'<br>')}</p></div>`; renderLine(html, 'output-line', outputBuffer); return true; } else {throw new Error("No content received.");}} catch(e) {if(!outputBuffer) outputDiv.removeChild(tl); await typeLine(`API call failed: ${e.message}`, 15, 'error-line', outputBuffer); return false;}};
            
            const enterEditor = (filePath, content = '') => {isEditing = true; let currentFile = filePath; terminalContentDiv.style.display = 'none'; editorContainer.style.display = 'flex'; let mode = 'text/plain'; if (filePath.endsWith('.js')) mode = 'javascript'; else if (filePath.endsWith('.html')) mode = 'htmlmixed'; else if (filePath.endsWith('.css')) mode = 'css'; const ta = document.getElementById('editor'); ta.value = content; codeMirrorInstance = CodeMirror.fromTextArea(ta, {mode: mode, theme: 'dracula', lineNumbers: true, autofocus: true, autoCloseBrackets: true, extraKeys: { "Ctrl-S": () => exitEditor(true, currentFile), "Ctrl-Q": () => exitEditor(false) }}); codeMirrorInstance.setSize("100%", "100%"); setTimeout(() => codeMirrorInstance.refresh(), 1);};
            
            const exitEditor = (save = false, filePath) => {if (save) { const { parent, name } = resolvePath(filePath); if (parent && name) { if (!parent.children[name]) { parent.children[name] = { type: constants.FS_TYPE_FILE, content: '' }; } parent.children[name].content = codeMirrorInstance.getValue(); saveFS(); } } codeMirrorInstance.toTextArea(); isEditing = false; editorContainer.style.display = 'none'; terminalContentDiv.style.display = 'flex'; if (save) renderLine(`Saved: <span class="file-line">${filePath}</span>`, 'success-line'); else renderLine("Edit cancelled.", 'info-line'); renderLine(''); commandInput.disabled = false; setTimeout(() => commandInput.focus(), 0);};

            // ////////////////////////////////////////////////////////////////////////////
            // --- COMMAND DEFINITIONS ---
            // ////////////////////////////////////////////////////////////////////////////

            const commands = {
                help: async (opts) => { await typeLine("Web Shell v7.4 (Commented Code)", 15, 'info-line', opts.buffer); const ht = ["--- System ---", "  help, clear, motd, theme, effect", "--- ✨ AI Co-Pilot ---", "  ai ask, ai code, ai debug", "--- Filesystem & Execution ---", "  ls, cd, pwd, mkdir, cat, edit, rm, js, cp, echo", "--- Pipeline ---", "  cmd > file.txt    - Redirect output to file (overwrite).", "  cmd >> file.txt   - Append output to file.", "  cmd1 | cmd2       - Pipe output of cmd1 to input of cmd2."]; for (const l of ht) { await typeLine(l, 5, 'output-line', opts.buffer); } return true; },
                
                echo: async (opts) => { let output = opts.args.join(' '); if ((output.startsWith('"') && output.endsWith('"')) || (output.startsWith("'") && output.endsWith("'"))) { output = output.substring(1, output.length - 1); } renderLine(output, 'output-line', opts.buffer); return true; },
                
                cat: async (opts) => { const path = opts.args[0]; if (!path) { await typeLine("cat: missing file operand", 15, 'error-line', opts.buffer); return false; } const { node } = resolvePath(path); if (!node) { await typeLine(`cat: ${path}: No such file or directory`, 15, 'error-line', opts.buffer); return false; } if (node.type === constants.FS_TYPE_DIRECTORY) { await typeLine(`cat: ${path}: Is a directory`, 15, 'error-line', opts.buffer); return false; } renderLine(node.content.replace(/</g, "&lt;").replace(/>/g, "&gt;"), 'output-line', opts.buffer); return true; },
                
                ls: async (opts) => { const path = opts.args[0] || '.'; const { node } = resolvePath(path); if (!node || node.type !== constants.FS_TYPE_DIRECTORY) { await typeLine(`ls: cannot access '${path}': Not a directory`, 15, 'error-line', opts.buffer); return false; } const entries = Object.entries(node.children); if (entries.length === 0) return true; for (const [name, childNode] of entries.sort()) { renderLine(`${name}${childNode.type === 'directory' ? '/' : ''}`, `${childNode.type}-line`, opts.buffer); } return true; },
                
                js: async (opts) => { const isLikelyExpression = (code) => { const statementKeywords = ['if', 'let', 'const', 'var', 'for', 'while', 'function', 'class', 'import', 'export', 'switch']; const trimmedCode = code.trim(); if (trimmedCode.includes(';')) return false; for (const keyword of statementKeywords) { if (new RegExp(`\\b${keyword}\\b`).test(trimmedCode)) return false; } return true; }; const input = opts.stdin || opts.args.join(' '); if (!input) { await typeLine("js: missing operand", 15, 'error-line', opts.buffer); return false; } const { node } = resolvePath(input); let codeToRun, isFile = false; if (node && node.type === constants.FS_TYPE_FILE) { codeToRun = node.content; isFile = true; } else { codeToRun = input; } if (isFile) { await typeLine(`Executing: <span class="file-line">${input}</span>`, 15, 'info-line', opts.buffer); } const startTime = performance.now(); const tc = { log: (...x) => renderLine(x.map(y => typeof y === 'object' ? JSON.stringify(y, null, 2) : String(y)).join(' '), 'output-line', opts.buffer), error: (...x) => renderLine(x.join(' '), 'error-line', opts.buffer) }; let success = true; try { const script = isFile || opts.stdin ? codeToRun.replace(/input/g, JSON.stringify(opts.stdin)) : (isLikelyExpression(codeToRun) ? `return (${codeToRun})` : codeToRun); const asyncFunction = new (Object.getPrototypeOf(async function () { }).constructor)('console', 'input', script); const result = await asyncFunction(tc, opts.stdin); if (!isFile && !opts.stdin && result !== undefined) { tc.log(result); } } catch (error) { tc.error(error.name + ': ' + error.message); success = false; } finally { const duration = (performance.now() - startTime).toFixed(2); await typeLine(`\n<span class="info-line">Script finished in ${duration}ms.</span>`, 15, 'output-line', opts.buffer); } return success; },
                
                cd: async ({args}) => { const path = args[0] || '~'; const { node, finalPath } = resolvePath(path); if (node && node.type === constants.FS_TYPE_DIRECTORY) { currentPath = finalPath; updatePrompt(); } else { await typeLine(`cd: no such file or directory: ${path}`, 15, 'error-line'); } return true; },
                
                pwd: async ({buffer}) => { await typeLine('/' + currentPath.join('/'), 15, 'output-line', buffer); return true; },
                
                mkdir: async ({args}) => { const dirName = args[0]; if (!dirName) { await typeLine("mkdir: missing operand", 15, 'error-line'); return false; } const { node, parent, name } = resolvePath(dirName); if (node) { await typeLine(`mkdir: cannot create directory '${name}': File exists`, 15, 'error-line'); return false; } if (!parent) { await typeLine(`mkdir: cannot create directory '${name}': No such file or directory`, 15, 'error-line'); return false; } parent.children[name] = { type: constants.FS_TYPE_DIRECTORY, children: {} }; saveFS(); return true; },
                
                rm: async ({args}) => { const path = args[0]; if (!path) { await typeLine("rm: missing operand", 15, 'error-line'); return false; } const { node, parent, name } = resolvePath(path); if (!node) { await typeLine(`rm: cannot remove '${path}': No such file or directory`, 15, 'error-line'); return false; } delete parent.children[name]; saveFS(); await typeLine(`Removed '${path}'`, 15, 'success-line'); return true; },
                
                cp: async ({args}) => { const [sourcePath, destPath] = args; if (!sourcePath || !destPath) { await typeLine("cp: missing file operand", 15, 'error-line'); return false; } const { node: sourceNode } = resolvePath(sourcePath); if (!sourceNode) { await typeLine(`cp: cannot stat '${sourcePath}': No such file or directory`, 15, 'error-line'); return false; } if (sourceNode.type === constants.FS_TYPE_DIRECTORY) { await typeLine(`cp: Omitting directory '${sourcePath}'`, 15, 'info-line'); return true; } let { node: destNode, parent: destParent, name: destName } = resolvePath(destPath); if (destNode && destNode.type === constants.FS_TYPE_DIRECTORY) { const sourceName = sourcePath.split('/').pop(); destParent = destNode; destName = sourceName; } if (!destParent) { await typeLine(`cp: cannot create regular file '${destPath}': No such directory`, 15, 'error-line'); return false; } destParent.children[destName] = { type: constants.FS_TYPE_FILE, content: sourceNode.content }; saveFS(); return true; },
                
                edit: async ({args}) => { const path = args[0]; if (!path) { await typeLine("edit: missing operand", 15, 'error-line'); return false; } const { node } = resolvePath(path); if (node && node.type === constants.FS_TYPE_DIRECTORY) { await typeLine(`edit: cannot edit '${path}': It is a directory`, 15, 'error-line'); return false; } enterEditor(path, node ? node.content : ''); return true; },
                
                effect: async ({args}) => { const [effectName, state] = args; if (!effectName || !state || (state !== 'on' && state !== 'off')) { await typeLine("Usage: effect crt <on|off>", 15, 'error-line'); return false; } applyEffect(effectName, state); await typeLine(`CRT effect turned ${state}.`, 15, 'success-line'); return true; },
                
                ai: async (opts) => { const subCommand = opts.args[0]; const prompt = opts.args.slice(1).join(' '); if (!subCommand) return await typeLine("Usage: ai <ask|code|debug> [prompt]", 15, 'error-line', opts.buffer), false; let fullPrompt; switch (subCommand.toLowerCase()) { case 'ask': if (!prompt) return await typeLine("Usage: ai ask [your question]", 15, 'error-line', opts.buffer), false; fullPrompt = `Answer the following question clearly and concisely. Request: ${prompt}`; break; case 'code': if (!prompt) return await typeLine("Usage: ai code [your request for code]", 15, 'error-line', opts.buffer), false; fullPrompt = `Generate a code snippet for the following request. Only provide the code, no explanation. Request: ${prompt}`; break; case 'debug': const filePath = opts.args[1]; if (!filePath) return await typeLine("Usage: ai debug [path/to/file]", 15, 'error-line', opts.buffer), false; const { node } = resolvePath(filePath); if (!node) return await typeLine(`debug: Cannot find file: ${filePath}`, 'error-line', opts.buffer), false; if (node.type !== constants.FS_TYPE_FILE) return await typeLine(`debug: '${filePath}' is not a file.`, 'error-line', opts.buffer), false; await typeLine(`✨ Analyzing <span class="file-line">${filePath}</span>...`, 'info-line', opts.buffer); fullPrompt = `You are an expert code reviewer. Analyze the following code snippet for bugs, errors, or potential improvements. Provide a clear, concise report of your findings. Explain the issues and suggest fixes.\n\nCODE:\n\`\`\`\n${node.content}\n\`\`\``; break; default: return await typeLine(`Unknown 'ai' command: ${subCommand}`, 15, 'error-line', opts.buffer), false; } return await callGemini(fullPrompt, opts.buffer); },
                
                motd: async ({buffer}) => { const art=['       .__           .__  .__   ','  ____ |  |__   ____ |  | |  |  ','_/ ___\\|  |  \\_/ __ \\|  | |  |  ','\\  \\___|   Y  \\  ___/|  |_|  |__',' \\___  >___|  /\\___  >____/____/','     \\/     \\/     \\/           ']; for(const l of art) { await typeLine(l, 10, 'ascii-art', buffer); } await typeLine("\nWelcome to \"chell\", your AI Co-Pilot.", 15, 'info-line', buffer); return true; },
                
                theme: async({args}) => { const t = args[0]; if (!t) { await typeLine("Themes:", 15, 'info-line'); renderLine(Object.keys(themes).map(t => `  - ${t}`).join('\n')); } else if (applyTheme(t)) { await typeLine(`Theme: '${t}'.`, 'success-line'); } else { await typeLine(`Error: Theme '${t}' not found.`, 'error-line'); } return true; },
                
                clear: () => { outputDiv.innerHTML = ''; return Promise.resolve(true); },
            };
            
            // ////////////////////////////////////////////////////////////////////////////
            // --- CORE COMMAND PROCESSOR ---
            // This is the main loop that parses and executes user commands.
            // ////////////////////////////////////////////////////////////////////////////
            const processCommand = async (commandStr) => {
                const promptUser = document.getElementById('prompt-user').textContent;
                const promptPath = promptPathSpan.textContent;
                const promptChar = document.getElementById('prompt-char').textContent;
                renderLine(`<span class="prompt-line">${promptUser}${promptPath}${promptChar}</span>${commandStr.replace(/</g,"&lt;").replace(/>/g,"&gt;")}`);
                
                commandInput.disabled = true;

                try {
                    if (commandStr.trim() !== "") { commandHistory.unshift(commandStr); if (commandHistory.length > 50) commandHistory.pop(); }
                    historyIndex = -1;

                    // --- Pipeline & Redirection Parsing ---
                    let pipelineStr = commandStr;
                    let redirection = null;
                    
                    if (commandStr.includes('>>')) { const parts = commandStr.split('>>'); pipelineStr = parts[0].trim(); redirection = { type: 'append', target: parts.slice(1).join('>>').trim() };
                    } else if (commandStr.includes('>')) { const parts = commandStr.split('>'); pipelineStr = parts[0].trim(); redirection = { type: 'overwrite', target: parts.slice(1).join('>').trim() }; }
                    
                    let commandsToRun = pipelineStr.split('|').map(s => s.trim()).filter(cmd => cmd);
                    let pipeBuffer = undefined;

                    for (let i = 0; i < commandsToRun.length; i++) {
                        const currentCommandStr = commandsToRun[i];
                        const parts = currentCommandStr.trim().split(/\s+/);
                        const baseCommand = parts[0].toLowerCase();
                        const args = parts.slice(1);
                        let outputBuffer = (i < commandsToRun.length - 1 || redirection) ? [] : null;

                        if (commands[baseCommand]) {
                            const success = await commands[baseCommand]({ args, stdin: pipeBuffer, buffer: outputBuffer });
                            if (!success) return; 
                            pipeBuffer = (outputBuffer !== null) ? outputBuffer.join('\n') : undefined;
                        } else {
                            await typeLine(`Command not found: ${baseCommand}`, 15, 'error-line');
                            return; 
                        }
                    }
                    
                    if (redirection) {
                        const contentToWrite = pipeBuffer === undefined ? '' : pipeBuffer;
                        const { parent, name } = resolvePath(redirection.target);
                        if (!parent || !name) { await typeLine(`Error: Cannot write to '${redirection.target}': Invalid path`, 15, 'error-line');
                        } else {
                            const existingNode = parent.children[name];
                            if (redirection.type === 'append' && existingNode && existingNode.type === constants.FS_TYPE_FILE) {
                                existingNode.content += (existingNode.content ? '\n' : '') + contentToWrite;
                            } else {
                                parent.children[name] = { type: constants.FS_TYPE_FILE, content: contentToWrite };
                            }
                            saveFS();
                        }
                    }
                } catch (error) {
                    console.error("An unexpected error occurred in processCommand:", error);
                    await typeLine(`An unexpected internal error occurred. Please check the browser console.`, 15, 'error-line');
                } finally {
                    if (!isEditing) {
                        await typeLine("");
                        commandInput.disabled = false;
                        commandInput.focus();
                    }
                }
            };

            // ////////////////////////////////////////////////////////////////////////////
            // --- EVENT LISTENERS & INITIAL LOAD ---
            // ////////////////////////////////////////////////////////////////////////////
            commandInput.addEventListener('keydown', async (event) => {
                if(event.key === 'Enter'){ event.preventDefault(); const command = commandInput.value; commandInput.value = ''; await processCommand(command); }
                else if (event.key === 'ArrowUp'){ event.preventDefault(); if(historyIndex < commandHistory.length - 1){ historyIndex++; commandInput.value = commandHistory[historyIndex]; } }
                else if (event.key === 'ArrowDown'){ event.preventDefault(); if(historyIndex > 0){ historyIndex--; commandInput.value = commandHistory[historyIndex]; } else { historyIndex = -1; commandInput.value = ''; } }
            });
            terminalDiv.addEventListener('click', (e) => { if(!isEditing && !e.target.closest('.CodeMirror')){ commandInput.focus(); } });

            const startTerminal = async () => {
                loadFS();
                applyTheme(localStorage.getItem('webShellTheme') || 'tokyo-night');
                const savedEffect = localStorage.getItem('webShellEffect');
                if (savedEffect === 'crt-on') applyEffect('crt', 'on');
                await commands.motd({});
                await typeLine("Type 'help' for a list of available commands.", 15);
                await typeLine("");
                commandInput.focus();
            };

            startTerminal();
        });
    </script>
</body>
</html>
